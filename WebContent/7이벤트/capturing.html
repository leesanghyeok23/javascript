<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>

	<link rel="stylesheet" href="css/event.css">
</head>
<body>
	BODY
		<div>
			DIV
				<section>
					SECTION
						<p>
							P
						</p>
				</section>
		</div>
		
		<script>
		
		/*
		   다른 for문의 문법 ( for ... of 문법)
		   
		   		for(let 변수  of  이터러블){
		   			
		   			//반복실행 할 코드 작성
		   			
		   		}
		
		변수 : 반복할때 마다 이터러블객체의 각 요소를 반복해서 꺼내와 저장할 변수 
		이터러블 : 배열, 문자열, Set, Map 등 반복가능한 객체 넣을 수 있다.
	
		//배열 생성
		const fruits = ["사과", "바나나",  "오렌지"];  // <---배열
		//                0        1        2     index
		//fruits배열에 저장된 문자열의 갯수만큼 반복해서 
		//0 index위치의 "사과" 부터   2 index위치에 저장된 "오렌지"를 차례대로 꺼내서
		//변수에 저장 후 반복해서 사용
		for(let  fruit   of  fruits){
			
			console.log(fruit);
					   //"사과"
					   //"바나나"
					   //"오렌지"
		}
		
		
		let str = "HELLO";
		
		//"HELLO" 문자열의 총 문자 갯수 만큼 반복 하는데
		// 01234  index
		//먼저 0 index  H를 가져와  let ch변수로 전달받아   {  console.log(ch);   }
		// ~~~~~~~
		//마지막 4 index O까지 가져와 let ch변수에 전달 받아    {  console.log(ch);   } 출력후
		//for  of 구문을 빠져나감 
		for(let ch  of  str){
   			
   			//반복실행 할 코드 작성
   			console.log(ch);
   			//"H"
   			//"E"
   			//"L"
   			//"L"
   			//"O"
   			
   		}
		*/
		
		
	   
			//현재 html파일에 작성된 모든 HTML태그들을 NodeList유사배열에 담아 선택해 옵니다.
			const elements = document.querySelectorAll("*");
	
			for(let element  of  elements){ 			
	   			//반복실행 할 코드 작성
				element.addEventListener("click", function(event){			
						console.log( event.target.tagName );
						//console.log( event.currentTarget.tagName);
				}, true );//true-> 캡처링 
	   			//만약 <body>BODY</body>영역을 클릭하면  
	   			//    <body></body>영역의 부모인 <html></html>영역의 click이벤트를 처리하고
	   			//	  그후 <body></body>영역의 click이벤트를 처리 하니 
	   			//1.  BODY  <--- <html><body>BODY</body></html> 
	   			//                부모영역의 click이벤트 처리 출력결과 BODY가 먼저 나오고
	   			
	   			//2.  BODY  <---- <body>BODY</body> click 이벤트가 직접 발생한 
	   			//                  자신 <body>BODY</body>요소 영역의 click이벤트 처리가 나중에 되어서
	   			//					BODY가 마지막에 한번더 출력됩니다.
	 
	   			//출력 결론  BODY
	   			//        BODY    
	   			//두번 출력
	   			
	   			
	   			
	   		}	
			
		/*
			//NodeList유사배열에 저장된 선택한 모든 HTML태그들을 순회하면서
			//click이벤트를 등록하고  각 HTML태그에 click발생하면 
			//event객체의 target속성과,  event객체의 currentTarget속성을 호출한 값 출력
			for(let i=0;   i<elements.length;   i++){
					
				elements[i].addEventListener("click",function(event){
					
					//10 개 의 HTML태그들 중에서   click이벤트가 발생당한 HTML태그의 정보는 
					//event객체가 가지고 있기때문에  event객체의 target속성을 호출합니다.
					console.log( event.target.tagName );
					
					//event객체의 currentTarget속성을 호출하면
					//이벤트 처리함수function(event){} 가 등록된 HTML태그를 반환합니다.
					//(현재 이벤트 처리함수가 실행되고 있는  HTML태그를 반환합니다.)
					//console.log( event.currentTarget.tagName);
						
				}, true); //true를 넣으면 캡처링 이벤트 전파 방식으로 이벤트 처리 하겠다
						  
						  //true를 넣으면 이벤트가 발생한 요소의 부모요소 부터 먼저 이벤트를 처리하고
						  //이벤트가 발생한 자기 자신 요소를 마지막으로 이벤트 처리 한다.
						  
			}
			*/
			
	
		
		</script>
		
		
</body>
</html>




