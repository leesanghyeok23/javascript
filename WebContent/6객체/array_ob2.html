<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<script>
	//주제 : 배열 생성 및 요소 접근
			
    //fruits라는 배열 참조변수를 선언하고, 
    //"Apple","Banana","Cherry"라는 세개의 문자열을 요소로 가지는 배열을 할당합니다
    let fruits = ["Apple", "Banana", "Cherry"];
	//				0         1         2            index
	
	//fruits배열의 첫번째 요소인 "Apple" 을 얻어와 출력합니다
	console.log(fruits[0]);//"Apple"
	
	//fruits배열에 저장된 요소의 총 갯수를 얻어와 출력합니다.
	console.log(fruits.length); //3
	
    //let fruits = ["Apple", "Banana", "Cherry"];
	//				0         1         2            index		
	
//배열에서 제공해 주는 메소드 이용!!!!!!!
	
	//배열 메모리의 가장 마지막 index 2 위치 뒤에 "Date"요소 추가
	fruits.push("Date"); // ["Apple", "Banana", "Cherry","Date"]
	//							0         1        2       3      index
	
	console.log(JSON.stringify(fruits));
	
	//배열 메모리의 가장 마지막 index 3위치에 저장된 "Date"요소를 제거하고 그값을 반환해 오자
	let value2 = fruits.pop();
		//"Date"          
		
	//반환한 "Date"요소를 출력
    console.log(value2);//"Date"
    
    //그리고 다시 fruits배열의 변화된 모습 출력!
    console.log(JSON.stringify(fruits)); //["Apple","Banana","Cherry"]
    									 //   0        1         2       index
    									 
    //배열 메모리의 가장 첫번째 칸에 저장된 "Apple"요소를 제거하고  제거한 값 "Apple" 추출(반환)
    console.log(   fruits.shift()  ); //"Apple"
    
    //그리고 다시 fruits배열의 변화된 모습 출력!
    console.log(JSON.stringify(fruits));// ["Banana", "Cherry"]
    									//     0         1           index
    									
	 //배열 메모리의  0 index위치 앞에 (가장 앞위치에) "Avodcado" 요소를 추가합니다.
	 fruits.unshift("Avodcado");// ["Avodcado","Banana", "Cherry"]
	 							//    0           1          2           index
	 							
     //그리고 다시 fruits배열의 변화된 모습 출력!
   	 console.log(JSON.stringify(fruits));							
    
 	//현재  배열 메모리 모습
	//let fruits = ["Avodcado","Banana", "Cherry"]
	//    				0           1          2           index	
	//반복 메소드 사용!
		//fruits배열 메모리에 저장된 각 요소(데이터)를 차례대로 반복해서 얻어 출력!
		//단! forEach메소드 사용!	
		//형태1.
		fruits.forEach(function(fruit){   console.log(fruit);   });
 										//Avodcado
										//Banana
										//Cherry
		//형태2.
     	 //이 경우 각 요소를 console.log로 출력하므로 
      	// "Avocado", "Banana", "Cherry"
		fruits.forEach(  fruit =>  console.log(fruit)   );
		

	
	    //반복메소드2
	    	//map()메소드
	    	//- 배열의 각요소에 대해 주어진 콜백함수function(){}를 호출하고,
	    	//  그 결과로 새로운 배열메모리를 생성해서 새로운 배열 메모리 자체를 반환하는 메소드
	    	//- 이 메소드는 배열에 저장된 원본데이터를 변경하지 않고
	    	//  계산에 의해 새로운 배열에 넣어 새로운 배열 메모리 자체의 주소를 반환합니다.

//현재  배열 메모리 모습
//let fruits = ["Avodcado","Banana", "Cherry"]
//    				0           1          2           index	
 let upperFriuts =  fruits.map(function(fruit){
	    	    			  //"Avodcdao".toUpperCase();  -> "AVODCADO"
	    	    			  //"Banana".toUpperCase();   -> "BANANA"
	    	    			  //"Cherry".toUpperCase();   -> "CHERRY"
  						return fruit.toUpperCase();
	    	    			  //새로운 배열메모리가 생성되면서 반복순선대로 새로운배열에 추가되어 저장됨
	    	    			  //["AVODCADO", "BANANA", "CHERRY"] 
  	
  					});
	  //fruits배열의 요소들을 가공한 새로운 배열upperFriuts 배열 모습 출력 
	 console.log(JSON.stringify(upperFriuts));	//["AVODCADO","BANANA","CHERRY"]
	 
	
	//화살표 함수 형태로  map메소드 호출
	let upperFriuts2 = fruits.map( fruit => fruit.toUpperCase()   );
		    	
	//fruits배열의 요소들을 가공한 새로운 배열upperFriuts2 배열 모습 출력 
	console.log(JSON.stringify(upperFriuts2));  //["AVODCADO","BANANA","CHERRY"]
	
	//-------------------------------------------------------------------
	//보충. map메소드 사용
	
	let numbers =  [1, 2, 3, 4, 5];
	//			    0  1  2  3  4   index
	
	//numbers배열 메모리에 저장되어 있는 모든 요소들을 차례대로 반복해서 얻어   
	//		요소 1 -> return   1  *  1  ->  1을 만들어   새로운 배열 자동생성   [ 1 ]
	//      요소 2 -> return   2  *  2  ->  4를 만들어  새로운 배열에 추가      [  1, 4 ]
	//		요소 3 -> return   3  *  3  ->  9를 만들어 새로운 배열에 추가      [  1,  4,  9]
	//  	요소 4 -> return   4 * 4    ->  16                       [1,   4,  9,  16]
     // 	 요소5 -> return   5 * 5    ->  25                       [1,   4,  9,  16, 25]
	let newNumbers = numbers.map( function(number){ return number * number;     });
	//[1,   4,  9,  16, 25]
	// 0     1   2   3   4   index
	
	//일반 for반복문을 이용해 newNubmers배열에 저장된 요소들을 각각 반복해서 얻어 console.log로 출력
	for(let i=0;   i<newNumbers.length;  i++){
		console.log(  newNumbers[i]       );
	}
	
	console.log("----------------------------------------------------");
	
	/*
		참고. map()
	*/
	let numbers2 = [1, 2, 3];			//<--- 배열
				//  0  1  2  index
	
	let context = { value: 'Hello' };  //<--- 객체
	
	let newNumbers2 =  numbers2.map(function(number){
		
		//현재 context객체의 value속성(키)의 값 'Hello'를 3번 반복해서 얻어 아래의 새로운 배열에 담습니다.
		return this.value;    // ['Hello','Hello','Hello']
			
	}, context);//map메소드의 두번째 인자로 특정 객체의 속성값들을 얻어
    			//새로운 배열에 담아 새로운 배열을 반환할수있다.
	
	console.log(   JSON.stringify(newNumbers2)   );//["Hello","Hello","Hello"]
	

	 //  let fruits = ["Avodcado","Banana", "Cherry"]   <- 현재 배열 모습 
	 //    				 0           1          2           index
	
	 //배열 객체가 제공하는 find()메소드
	 
	 //조건에 맞는 요소 찾기
	      //배열의 요소 중 조건을 만족하는 첫 번째 요소를 반환합니다.
	      //여기서는 요소가 "B"로 시작하는 첫 번째 과일을 찾기 위해
	      //fruit.startsWith("B"); 조건검사 메소드를 호출한 것이다
	      //'Banana'가  "B"로 시작하므로 조건을 만족하여 
	     //조건에 만족한 'Banana'문자열을 반환해 줍니다. 
	 let foundFruit = fruits.find( fruit  =>    fruit.startsWith("B")  );
	 	//'Banana'
	 
	 console.log(foundFruit);	 	
	 //  let fruits = ["Avodcado","Banana", "Cherry"]   <- 현재 배열 모습 
	 //    				 0           1          2           index
	 
	 	//배열의 slice(index) 메소드
	 	//- 배열에 저장된 일부 요소를 추출해서 새로운 배열메모리로 만들어 반환
	 	//- 배열에 특정 부분을 잘라서 새로운 배열을 만들어 반환하는 메소드
	 	
	 	//여기서는 index 1부터 배열의 끝 2 index위치에 저장된 요소까지의 데이터를 잘라서
	 	//["Banana", "Cherry"] 자른 새로운 배열메모리를 반환 받자
	 	let someFruits = fruits.slice(1); 
	 	console.log(   JSON.stringify(someFruits)   );//["Banana","Cherry"]
	 	
	 	
	
	    	
	
	</script>

</body>
</html>






